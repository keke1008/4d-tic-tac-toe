<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4æ¬¡å…ƒä¸‰ç›®ä¸¦ã¹ - Rotating Tesseract</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a0a2e 0%, #0a0a1a 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            height: 100%;
            padding: 20px;
        }

        h1 {
            font-size: 2.5em;
            text-align: center;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 3s ease-in-out infinite;
            margin-top: 20px;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 20px rgba(255, 0, 255, 0.5)); }
            50% { filter: brightness(1.5) drop-shadow(0 0 30px rgba(0, 255, 255, 0.8)); }
        }

        #canvas {
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.3),
                        inset 0 0 50px rgba(0, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }

        #info {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px 40px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 0, 255, 0.2);
            max-width: 90%;
        }

        #status {
            font-size: 1.5em;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            font-size: 1em;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(0, 255, 255, 0.3));
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        button:hover {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.5), rgba(0, 255, 255, 0.5));
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            transform: translateY(-2px);
        }

        #rotation-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .rotation-btn {
            padding: 8px 12px;
            font-size: 0.85em;
        }

        #hint {
            font-size: 0.9em;
            color: #aaa;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>4æ¬¡å…ƒå›è»¢ä¸‰ç›®ä¸¦ã¹</h1>
        <canvas id="canvas" width="900" height="600"></canvas>
        <div id="info">
            <div id="status">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ X ã®ç•ªã§ã™</div>
            <div id="hint">4æ¬¡å…ƒç«‹æ–¹ä½“ã‚’å›è»¢ã•ã›ã¦ã‚»ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã€‚4ã¤ä¸¦ã¹ãŸã‚‰å‹åˆ©ï¼</div>
            <div id="controls">
                <button onclick="game.reset()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
                <button onclick="game.toggleAutoRotate()">
                    <span id="rotate-status">â¸ è‡ªå‹•å›è»¢åœæ­¢</span>
                </button>
                <button onclick="game.changeRotationSpeed(-1)">ğŸŒ å›è»¢é…ã</button>
                <button onclick="game.changeRotationSpeed(1)">ğŸš€ å›è»¢é€Ÿã</button>
            </div>
            <div id="rotation-controls">
                <button class="rotation-btn" onclick="game.manualRotate('xy')">âŸ² XYå›è»¢</button>
                <button class="rotation-btn" onclick="game.manualRotate('xz')">âŸ² XZå›è»¢</button>
                <button class="rotation-btn" onclick="game.manualRotate('xw')">âŸ² XWå›è»¢ âœ¨</button>
                <button class="rotation-btn" onclick="game.manualRotate('yz')">âŸ² YZå›è»¢</button>
                <button class="rotation-btn" onclick="game.manualRotate('yw')">âŸ² YWå›è»¢ âœ¨</button>
                <button class="rotation-btn" onclick="game.manualRotate('zw')">âŸ² ZWå›è»¢ âœ¨</button>
            </div>
        </div>
    </div>

    <script>
        class Tesseract4DGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;

                // ã‚²ãƒ¼ãƒ è¨­å®š
                this.gridSize = 4; // 4x4x4x4
                this.cellSpacing = 0.6; // ã‚»ãƒ«é–“ã®é–“éš”
                this.cellSize = 0.15; // å„ã‚»ãƒ«ã®å¤§ãã•

                // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
                this.board = this.createEmptyBoard();
                this.currentPlayer = 'X';
                this.gameOver = false;
                this.winner = null;

                // 4æ¬¡å…ƒå›è»¢è§’åº¦
                this.rotations = {
                    xy: 0, xz: 0, xw: 0,
                    yz: 0, yw: 0, zw: 0
                };

                // å›è»¢è¨­å®š
                this.autoRotate = true;
                this.rotationSpeed = 1;
                this.baseSpeed = 0.003;

                // ã‚»ãƒ«ã®4æ¬¡å…ƒåº§æ¨™
                this.cells = this.generateCells();

                // ãƒã‚¦ã‚¹ã®ä½ç½®
                this.mousePos = { x: 0, y: 0 };
                this.hoveredCell = null;

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                this.animate();
            }

            createEmptyBoard() {
                const board = [];
                for (let w = 0; w < this.gridSize; w++) {
                    board[w] = [];
                    for (let z = 0; z < this.gridSize; z++) {
                        board[w][z] = [];
                        for (let y = 0; y < this.gridSize; y++) {
                            board[w][z][y] = [];
                            for (let x = 0; x < this.gridSize; x++) {
                                board[w][z][y][x] = null;
                            }
                        }
                    }
                }
                return board;
            }

            generateCells() {
                const cells = [];
                const offset = (this.gridSize - 1) * this.cellSpacing / 2;

                for (let w = 0; w < this.gridSize; w++) {
                    for (let z = 0; z < this.gridSize; z++) {
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                cells.push({
                                    pos4d: [
                                        x * this.cellSpacing - offset,
                                        y * this.cellSpacing - offset,
                                        z * this.cellSpacing - offset,
                                        w * this.cellSpacing - offset
                                    ],
                                    coords: { x, y, z, w },
                                    value: null
                                });
                            }
                        }
                    }
                }
                return cells;
            }

            rotate4D(point, rotations) {
                let [x, y, z, w] = point;

                // XYå›è»¢
                if (rotations.xy) {
                    const cos = Math.cos(rotations.xy);
                    const sin = Math.sin(rotations.xy);
                    [x, y] = [x * cos - y * sin, x * sin + y * cos];
                }

                // XZå›è»¢
                if (rotations.xz) {
                    const cos = Math.cos(rotations.xz);
                    const sin = Math.sin(rotations.xz);
                    [x, z] = [x * cos - z * sin, x * sin + z * cos];
                }

                // XWå›è»¢ï¼ˆ4æ¬¡å…ƒï¼ï¼‰
                if (rotations.xw) {
                    const cos = Math.cos(rotations.xw);
                    const sin = Math.sin(rotations.xw);
                    [x, w] = [x * cos - w * sin, x * sin + w * cos];
                }

                // YZå›è»¢
                if (rotations.yz) {
                    const cos = Math.cos(rotations.yz);
                    const sin = Math.sin(rotations.yz);
                    [y, z] = [y * cos - z * sin, y * sin + z * cos];
                }

                // YWå›è»¢ï¼ˆ4æ¬¡å…ƒï¼ï¼‰
                if (rotations.yw) {
                    const cos = Math.cos(rotations.yw);
                    const sin = Math.sin(rotations.yw);
                    [y, w] = [y * cos - w * sin, y * sin + w * cos];
                }

                // ZWå›è»¢ï¼ˆ4æ¬¡å…ƒï¼ï¼‰
                if (rotations.zw) {
                    const cos = Math.cos(rotations.zw);
                    const sin = Math.sin(rotations.zw);
                    [z, w] = [z * cos - w * sin, z * sin + w * cos];
                }

                return [x, y, z, w];
            }

            project4Dto3D(point) {
                const distance = 2.5;
                const [x, y, z, w] = point;
                const factor = distance / (distance - w);
                return [x * factor, y * factor, z * factor, w];
            }

            project3Dto2D(point) {
                const distance = 4;
                const [x, y, z] = point;
                const factor = distance / (distance - z);
                const scale = 200;
                const screenX = x * factor * scale + this.width / 2;
                const screenY = -y * factor * scale + this.height / 2;
                return [screenX, screenY, z, factor];
            }

            drawCell(cell, rotatedPos, projectedPos, isHovered) {
                const ctx = this.ctx;
                const [screenX, screenY, depth, perspective] = projectedPos;
                const [x3d, y3d, z3d, w] = rotatedPos;

                // æ·±åº¦ã¨Wåº§æ¨™ã«åŸºã¥ã„ã¦è‰²ã‚’æ±ºå®š
                const depthFactor = (depth + 3) / 6;
                const wFactor = (w + 2) / 4;

                // 4æ¬¡å…ƒã®ä½ç½®ã«åŸºã¥ã„ã¦è‰²ç›¸ã‚’å¤‰åŒ–
                const hue = (wFactor * 120 + 240) % 360;
                const opacity = 0.3 + depthFactor * 0.6;

                // ã‚»ãƒ«ã®ã‚µã‚¤ã‚ºï¼ˆé€è¦–åŠ¹æœã‚’é©ç”¨ï¼‰
                const size = this.cellSize * 200 * perspective;

                // ã‚»ãƒ«ã®å€¤ã«å¿œã˜ã¦æç”»
                const value = this.board[cell.coords.w][cell.coords.z][cell.coords.y][cell.coords.x];

                // ãƒ›ãƒãƒ¼åŠ¹æœ
                if (isHovered && !this.gameOver) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `hsla(${hue}, 100%, 70%, 0.8)`;
                }

                // ã‚»ãƒ«ã®èƒŒæ™¯
                ctx.fillStyle = `hsla(${hue}, 70%, 50%, ${opacity * 0.3})`;
                ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${opacity})`;
                ctx.lineWidth = isHovered ? 3 : 1.5;

                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.shadowBlur = 0;

                // X ã¾ãŸã¯ O ã‚’æç”»
                if (value) {
                    ctx.font = `bold ${size * 1.5}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    if (value === 'X') {
                        ctx.fillStyle = `rgba(255, 100, 255, ${opacity})`;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(255, 100, 255, 0.9)';
                    } else {
                        ctx.fillStyle = `rgba(100, 255, 255, ${opacity})`;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(100, 255, 255, 0.9)';
                    }

                    ctx.fillText(value, screenX, screenY);
                    ctx.shadowBlur = 0;
                }

                // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã‚»ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¡¨ç¤ºï¼ˆå°ã•ãï¼‰
                if (isHovered) {
                    ctx.font = '10px monospace';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    const coords = `(${cell.coords.x},${cell.coords.y},${cell.coords.z},${cell.coords.w})`;
                    ctx.fillText(coords, screenX, screenY + size + 12);
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
            }

            handleClick(e) {
                if (this.gameOver || !this.hoveredCell) return;

                const cell = this.hoveredCell;
                const { x, y, z, w } = cell.coords;

                // ã‚»ãƒ«ãŒç©ºãªã‚‰é…ç½®
                if (!this.board[w][z][y][x]) {
                    this.board[w][z][y][x] = this.currentPlayer;

                    // å‹åˆ©åˆ¤å®š
                    if (this.checkWin(w, z, y, x)) {
                        this.gameOver = true;
                        this.winner = this.currentPlayer;
                        document.getElementById('status').textContent =
                            `ğŸ‰ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${this.currentPlayer} ã®å‹åˆ©ï¼`;
                    } else if (this.isBoardFull()) {
                        this.gameOver = true;
                        document.getElementById('status').textContent = 'å¼•ãåˆ†ã‘ï¼';
                    } else {
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼äº¤ä»£
                        this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                        document.getElementById('status').textContent =
                            `ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ${this.currentPlayer} ã®ç•ªã§ã™`;
                    }
                }
            }

            checkWin(w, z, y, x) {
                const player = this.currentPlayer;
                const size = this.gridSize;

                // å…¨ã¦ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’ç”Ÿæˆ
                const directions = [];
                for (let dw = -1; dw <= 1; dw++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dw === 0 && dz === 0 && dy === 0 && dx === 0) continue;
                                directions.push([dw, dz, dy, dx]);
                            }
                        }
                    }
                }

                // å„æ–¹å‘ã§4ã¤ä¸¦ã‚“ã§ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                for (const [dw, dz, dy, dx] of directions) {
                    let count = 1;

                    // æ­£æ–¹å‘
                    for (let i = 1; i < size; i++) {
                        const nw = w + dw * i;
                        const nz = z + dz * i;
                        const ny = y + dy * i;
                        const nx = x + dx * i;

                        if (nw < 0 || nw >= size || nz < 0 || nz >= size ||
                            ny < 0 || ny >= size || nx < 0 || nx >= size) break;

                        if (this.board[nw][nz][ny][nx] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }

                    // è² æ–¹å‘
                    for (let i = 1; i < size; i++) {
                        const nw = w - dw * i;
                        const nz = z - dz * i;
                        const ny = y - dy * i;
                        const nx = x - dx * i;

                        if (nw < 0 || nw >= size || nz < 0 || nz >= size ||
                            ny < 0 || ny >= size || nx < 0 || nx >= size) break;

                        if (this.board[nw][nz][ny][nx] === player) {
                            count++;
                        } else {
                            break;
                        }
                    }

                    if (count >= size) return true;
                }

                return false;
            }

            isBoardFull() {
                for (let w = 0; w < this.gridSize; w++) {
                    for (let z = 0; z < this.gridSize; z++) {
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                if (!this.board[w][z][y][x]) return false;
                            }
                        }
                    }
                }
                return true;
            }

            reset() {
                this.board = this.createEmptyBoard();
                this.currentPlayer = 'X';
                this.gameOver = false;
                this.winner = null;
                document.getElementById('status').textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ X ã®ç•ªã§ã™';
            }

            toggleAutoRotate() {
                this.autoRotate = !this.autoRotate;
                document.getElementById('rotate-status').textContent =
                    this.autoRotate ? 'â¸ è‡ªå‹•å›è»¢åœæ­¢' : 'â–¶ è‡ªå‹•å›è»¢é–‹å§‹';
            }

            changeRotationSpeed(delta) {
                this.rotationSpeed = Math.max(0.1, Math.min(5, this.rotationSpeed + delta * 0.5));
            }

            manualRotate(plane) {
                this.rotations[plane] += 0.15;
            }

            animate() {
                // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢ï¼ˆãƒˆãƒ¬ã‚¤ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
                this.ctx.fillStyle = 'rgba(10, 10, 26, 0.2)';
                this.ctx.fillRect(0, 0, this.width, this.height);

                // è‡ªå‹•å›è»¢
                if (this.autoRotate) {
                    this.rotations.xw += this.baseSpeed * this.rotationSpeed;
                    this.rotations.yz += this.baseSpeed * this.rotationSpeed * 0.7;
                    this.rotations.zw += this.baseSpeed * this.rotationSpeed * 0.5;
                }

                // å…¨ã‚»ãƒ«ã‚’å›è»¢ãƒ»æŠ•å½±ãƒ»ã‚½ãƒ¼ãƒˆ
                const projectedCells = this.cells.map(cell => {
                    // ãƒœãƒ¼ãƒ‰çŠ¶æ…‹ã‚’æ›´æ–°
                    cell.value = this.board[cell.coords.w][cell.coords.z][cell.coords.y][cell.coords.x];

                    const rotated = this.rotate4D(cell.pos4d, this.rotations);
                    const projected3d = this.project4Dto3D(rotated);
                    const projected2d = this.project3Dto2D(projected3d);

                    return {
                        cell,
                        rotated,
                        projected: projected2d,
                        depth: projected2d[2] // Zåº§æ¨™ã§ã‚½ãƒ¼ãƒˆ
                    };
                });

                // æ·±åº¦ã‚½ãƒ¼ãƒˆï¼ˆå¥¥ã‹ã‚‰æ‰‹å‰ï¼‰
                projectedCells.sort((a, b) => a.depth - b.depth);

                // ãƒ›ãƒãƒ¼æ¤œå‡º
                this.hoveredCell = null;
                let minDist = 20; // ãƒ›ãƒãƒ¼æ¤œå‡ºã®æœ€å°è·é›¢

                // å…¨ã‚»ãƒ«ã‚’æç”»
                projectedCells.forEach(({ cell, rotated, projected, depth }) => {
                    const [screenX, screenY] = projected;
                    const dist = Math.hypot(this.mousePos.x - screenX, this.mousePos.y - screenY);

                    if (dist < minDist && !cell.value) {
                        minDist = dist;
                        this.hoveredCell = cell;
                    }

                    const isHovered = (this.hoveredCell === cell);
                    this.drawCell(cell, rotated, projected, isHovered);
                });

                // æ¥ç¶šç·šã‚’æç”»ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šãƒ†ãƒƒã‚»ãƒ©ã‚¯ãƒˆã®ã‚¨ãƒƒã‚¸ï¼‰
                this.drawConnections(projectedCells);

                requestAnimationFrame(() => this.animate());
            }

            drawConnections(projectedCells) {
                const ctx = this.ctx;

                // éš£æ¥ã‚»ãƒ«ã‚’æ¥ç¶šï¼ˆã‚°ãƒªãƒƒãƒ‰æ§‹é€ ã‚’å¯è¦–åŒ–ï¼‰
                projectedCells.forEach(({ cell, projected }) => {
                    const [x1, y1, depth] = projected;
                    const { x, y, z, w } = cell.coords;

                    // Xè»¸æ–¹å‘ã®æ¥ç¶š
                    if (x < this.gridSize - 1) {
                        const neighborIndex = this.getCellIndex(x + 1, y, z, w);
                        const neighbor = projectedCells[neighborIndex];
                        if (neighbor) {
                            const [x2, y2, depth2] = neighbor.projected;
                            const avgDepth = (depth + depth2) / 2;
                            const opacity = 0.05 + (avgDepth + 3) / 30;

                            ctx.strokeStyle = `rgba(100, 200, 255, ${opacity})`;
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }
                });
            }

            getCellIndex(x, y, z, w) {
                return w * this.gridSize * this.gridSize * this.gridSize +
                       z * this.gridSize * this.gridSize +
                       y * this.gridSize +
                       x;
            }
        }

        // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
        const game = new Tesseract4DGame();
    </script>
</body>
</html>
